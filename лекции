лекция.
тема сфера применения языка  python.
Python (в русском языке распространено название пито́н) — высокоуровневый язык программирования общего назначения, ориентированный на повышение производительности разработчика и читаемости кода.
Python поддерживает несколько парадигм программирования:
структурное;
объектно-ориентированное(ООП);
функциональное;
императивное;
аспектно-ориентированное.
Основные архитектурные черты:
динамическая сильная неявная типизация;
автоматическое управление памятью;
полная интроспекция;
механизм обработки исключений;
поддержка многопоточных вычислений;
и удобные высокоуровневые структуры данных.
PYTHON и ПИТОН
Назван язык не в честь змеи, а в честь английской комик-группы «Монти Пайтон», снявшейся в телешоу «Летающий цирк Монти Пайтона» в 1969-1974 годах в жанре абсурдистского юмора.
PEP – Python Enhancement Proposal (Предложения по развитию Python) — это документ со стандартизированным дизайном, предоставляющий общую информацию о языке Python,
включая новые предложения, описания
и разъяснения возможностей языка.
PEP предлагаются как основной источник для предложения новых возможностей и для разъяснения выбора того или иного дизайна для всех основных элементов языка.
Выдающиеся PEP рецензируются, комментируются и утверждаются Гвидо ван Россумом, имеющим в проекте статус
«великодушного пожизненного диктатора».
Основная идея - улучшение переносимости между платформами и компьютерами. Не гарантируется, что на различных системах исполняемый файл будет лежать по пути, который указан в shebang. Использование env позволяет снизить этот риск за счет запуска команды на основе данных из переменной среды
тема 2 "интерпретатор и среда разработки"
 Интерпрета́тор (языка программирования) – Программа или техническое средство, выполняющее интерпретацию. Вид транслятора, осуществляющего пооператорную (покомандную) обработку и выполнение исходной программы или запроса (в отличие от компилятора, транслирующего всю программу без её выполнения). Программа (иногда аппаратное средство), анализирующая команды или операторы программы и тут же выполняющая их. Языковый процессор, который построчно анализирует исходную программу и одновременно выполняет предписанные действия, а не формирует на машинном языке скомпилированную программу, которая выполняется впоследствии.
Простой интерпретатор анализирует и тут же выполняет (собственно интерпретация) программу покомандно (или построчно), по мере поступления её исходного кода на вход интерпретатора. Достоинство такого подхода является мгновенная реакция. Недостаток — такой интерпретатор обнаруживает ошибки в тексте программы только при попытке выполнения команды (или строки) с ошибкой. Алгоритм работы простого интерпретатора 1. прочитать инструкцию; 2. проанализировать инструкцию и определить соответствующие действия; 3. выполнить соответствующие действия; 4. если не достигнуто условие завершения программы, прочитать следующую инструкцию и перейти к пункту 2.
Достоинства Большая переносимость интерпретируемых программ — программа будет работать на любой платформе, на которой есть соответствующий интерпретатор. Как правило, более совершенные и наглядные средства диагностики ошибок в исходных кодах. Упрощение отладки исходных кодов программ. Меньшие размеры кода по сравнению с машинным кодом, полученным после обычных компиляторов. Недостатки Интерпретируемая программа не может выполняться отдельно без программы-интерпретатора. Сам интерпретатор при этом может быть очень компактным. Интерпретируемая программа выполняется медленнее, поскольку промежуточный анализ исходного кода и планирование его выполнения требуют дополнительного времени в сравнении с непосредственным исполнением машинного кода, в который мог бы быть скомпилирован исходный код. Практически отсутствует оптимизация кода, что приводит к дополнительным потерям в скорости работы интерпретируемых программ.
тема "типы данных переменных и операторы"
В Си существует всего лишь несколько базовых типов:
char - единичный байт, который может содержать один символ из допустимого символьного набора;
int - целое, обычно отображающее естественное представление целых в машине;
float - число с плавающей точкой одинарной точности;
double - число с плавающей точкой двойной точности.
В таких объявлениях слово int можно опускать, что обычно и делается. Если только не возникает противоречий со здравым смыслом, short int и long int должны быть разной длины, а int соответствовать естественному размеру целых на данной машине. Чаще всего для представления целого, описанного с квалификатором short, отводится 16 бит, с квалификатором long - 32 бита, а значению типа int - или 16, или 32 бита. Разработчики компилятора вправе сами выбирать подходящие размеры, сообразуясь с характеристиками своего компьютера и соблюдая следующие ограничения: значения типов short и int представляются по крайней мере 16 битами; типа long - по крайней мере 32 битами; размер short не больше размера int, который в свою очередь не больше размера long.
Квалификаторы signed (со знаком) или unsigned (без знака) можно применять к типу char и любому целочисленному типу. Значения unsigned всегда положительны или равны нулю и подчиняются законам арифметики по модулю 2n, где n - количество бит в представлении типа. Так, если значению char отводится 8 битов, то unsigned char имеет значения в диапазоне от 0 до 255, a signed char – от -128 до 127 (в машине с двоичным дополнительным кодом). Являются ли значения типа просто char знаковыми или беззнаковыми, зависит от реализации, но в любом случае коды печатаемых символов положительны.
Тип long double предназначен для арифметики с плавающей точкой повышенной точности. Как и в случае целых, размеры объектов с плавающей точкой зависят от реализации; float, double и long double могут представляться одним размером, а могут - двумя или тремя разными размерами.
Именованные константы для всех размеров вместе с другими характеристиками машины и компилятора содержатся в стандартных заголовочных файлах <limits.h> и <float.h> (см. приложение B).
тема "контейнеры"
Конте́йнер в программировании — тип, позволяющий инкапсулировать в себе объекты других типов. Контейнеры, в отличие от коллекций, реализуют конкретную структуру данных.
Среди «широких масс» программистов наиболее известны контейнеры, построенные на основе шаблонов, однако существуют и реализации в виде библиотек (наиболее широко известна библиотека GLib). Кроме того, применяются и узкоспециализированные решения. Примерами контейнеров в C++ являются контейнеры из стандартной библиотеки (STL) — map, vector и др. В контейнерах часто встречается реализация алгоритмов для них.
Контейнер — это двунаправленный связанный список, который обеспечивает двунаправленный доступ, быструю вставку и быстрое удаление в любом месте в контейнере, но не может получить случайный доступ к элементу в контейнере. Дополнительные сведения см. в разделе класс.
тема "операция ввода и вывода с файлами"
При работе с файлами выполняются операции ввода – вывода. Операция ввода означает перепись данных с внешнего устройства (из входного файла) в основную память ЭВМ, операция вывода – это пересылка данных из основной памяти на внешнее устройство (в выходной файл).
Файлы на внешних устройствах часто называют физическими файлами. Их имена определяются операционной системой. В программах на языке Паскаль имена файлов задаются с помощью строк. Например, имя файла на диске может иметь вид
'A:\LAB1.DAT'
'c:\ABC150\pr.pas'
'dat.pas'.
Для работы с файлами в программе необходимо определить файловую переменную. Турбо Паскаль поддерживает три файловых типа: текстовые файлы, типизированные файлы, нетипизированные файлы.
Описание типизированных файлов имеет вид
var f1: File of T;
Здесь T – тип компоненты файла. Примеры описания файловой переменной компонентного типа:
type M=array[1..500] of Longint;
var fLi: File of M;
f1: File of Real;
f2: File of Integer;
Бестиповые файлы описываются с помощью служебного слова File:
var f1: File;
Особое место в языке Паскаль занимают текстовые файлы, компоненты которых имеют символьный тип. Для описания текстовых файлов в языке определен стандартный тип Тext:
var TF1,TF2: Text;
Текстовые файлы представляют собой последовательность строк, а строки – последовательность символов. Строки имеют переменную длину, каждая строка завершается признаком конца строки. Иначе говоря, описанные выше файловые переменные можно было описать так:
var TF1,TF2: File of Char;
Будем использовать первый вариант описания.
Поскольку работа с текстовыми файлами более удобна в использовании и чаще применяется, то дальше рассматриваем именно её.
Файловые переменные, которые описаны в программе, называют логическими файлами. Все основные процедуры и функции, обеспечивающие ввод-вывод данных, работают только с логическими файлами. Физический файл должен быть связан с логическим до выполнения процедур открытия файлов.
Турбо Паскаль вводит ряд процедур и функций, применимых для любых типов файлов:
Assign (var f; FileName: String);
Процедура связывает логический файл f с физическим файлом, полное имя которого задано в строке FileName.
Reset (var f);
Процедура открывает логический файл f для последующего чтения данных, или, как говорят, открывает входной файл. Если физического файла не существует, то возникает ошибка. После успешного выполнения процедуры Reset файл готов к чтению из него первого элемента. Указатель файла устанавливается на начало.
Rewrite (var f);
Процедура открывает логический файл f для последующей записи данных (открывает выходной файл). Если физического файла не существует, то процедура создаст и откроет его. Если физический файл уже существует, то процедура откроет его и уничтожит все находящиеся в нём данные. После успешного выполнения этой процедуры файл готов к записи в него первого элемента. Указатель файла устанавливается на начало.
Append (var f: Text);
Процедура служит для специального открытия выходных текстовых файлов. Она применима к уже существующим физическим файлам и открывает их для дозаписи в конец файла. Указатель файла устанавливается за последним элементом.
Close (var f);
Процедура закрывает открытый до этого логический файл. Вызов процедуры Close необходим при завершении работы с файлом. Если по какой-то причине процедура Close не будет выполнена, файл все же будет создан на внешнем устройстве, но содержимое последнего буфера в него не будет перенесено. Для входных файлов использование оператора закрытия файла необязательно.
EOF (var f): Boolean;
Логическая функция возвращает значение TRUE, когда при чтении достигнет конца файла. Это означает, что уже прочитан последний элемент в файле или файл после открытия оказался пуст.
Rename (var f; NewName: String);
Процедура позволяет переименовать физический файл на диске, связанный с логическим файлом f. Переименование возможно после закрытия файла.
Erase(var f);
Процедура уничтожает физический файл на диске, который был связан с файловой переменной f. Файл к моменту вызова процедуры Erase должен быть закрыт.
IOResult: Integer;
Функция возвращает целое число, соответствующее коду последней ошибки ввода-вывода. При нормальном завершении операции функция вернет значение 0. Значение функции IOResult необходимо присваивать какой-либо переменной, т. к. при каждом вызове функция обнуляет свое значение. Функция IOResult работает только при выключенном режиме проверок ошибок ввода-вывода или с ключом компиляции {$I-}.
Для операций ввода-вывода используют стандартные процедуры Read и Write, в которых первым параметром в списке стоит файловая переменная, указывающая, с каким файлом требуется провести операцию.
Read(T,a,b,c);
– вводит значения переменных a,b,c из файла T.
Write(T,x,y);
– выводит значения переменных x,y в файл T.










